#<
Design a controller for turn signals. There are is a left and a right turn
signal. The left signal is activated and deactivated by the "l" key. The right
signal is activated and deactivated by the "r" key. An active signal light
should blink at a rate of 1 Hz (500 ms on, 500 ms off). At most one signal may
be active at any one time.

There are two main functions to implement. The key-press function is called
whenever a key is pressed. The tick function is called at a rate of 60 Hz and
asks for the next state given the current state. Follow a design recipe and
think about tests cases first (key-press-test, tick-test). You also need to
set the initial state and implement the helper functions left-light-on? and 
right-light-on?.
>#

# chosen design recipe:
# todo: ...
Blinker: {
    Active: (side :Str, powered :Bool, LastTimestamp :Int)
    Inactive: ()
} datadef
#"Left" activeblinker time-millis lasttimestamp


# todo: set initial state
"Right" false time-millis active initial-state!


# Called on key press. Computes the next state depending on state, key, and time.
key-press: (state :Obj, key :Str, now :Int -> :Obj) {
    

state active?{
    "Active" println
    {
        {key "r" = state active-side "Right" = and}{
            "Right off" println
            inactive
        }

        {key "r" = state active-side "Left" = and}{
            "Right on" println
            state "Right" active-side-set
        }

        {key "l" = state active-side "Left" = and}{
            "Left off" println
            inactive
        }

        {key "l" = state active-side "Right" = and}{
            "Left on" println
            state "Left" active-side-set
        }
    } cond
}{
    "Inactive" println
    {
        {key "r" =}{
            "Right on" println
            "Right" true time-millis active
        }

        {key "l" =}{
            "Left on" println
            "Left" true time-millis active
        }
    }cond
}if

} fun

# Called on key press. Inserts timestamp and calls key-press.
key-press-without-time: {
    time-millis key-press
} !

key-press-test: {
    # todo: add examples and expected results
    # ... key-press ... test=
    # ... key-press ... test=
    # ... key-press ... test=
    test-stats
} fun

key-press-test

# Called at 60 Hz. Computes the next state depending on the current state and time.
tick: (state :Obj, now :Int -> :Obj) { #|| Takes state and time-millis from tick-without-time and returns the next state.
    {
        {state active?}{
            state active-LastTimestamp 500 + now <= {
                {
                    {state active-powered true =}{state false active-powered-set time-millis active-LastTimestamp-set}
                    {state active-powered false =}{state true active-powered-set time-millis active-LastTimestamp-set}
                }cond
            }{
                state
            } if
        }

        {state inactive?}{
            state
        }
    }cond




     # todo: compute the next state
    

} fun

# Called at 60 Hz. Inserts timestamp and calls tick.
tick-without-time: {
    time-millis tick
} !

tick-test: {
    # todo: add examples and expected results
    # ... tick ... test=
    # ... tick ... test=
    # ... tick ... test=
    test-stats
} fun

tick-test

# Returns true iff the left light is currently on (emitting light).
left-light-on?: (state :Obj -> :Bool) {
    state active?
    {
        state active-powered true = 
        state active-side "Left" =
        and
    }{
        false
    }if
} fun

# Returns true iff the right light is currently on (emitting light).
right-light-on?: (state :Obj -> :Bool) {
    state active?
    {
        state active-powered true = 
        state active-side "Right" =
        and
    }{
        false
    }if # todo: implement
} fun

# Graphics output code below this point.
# Don't change code below this point, except for calling animate 
# at the very bottom (when your tests work).
# The code calls key-press-without-time, tick-without-time, 
# initial-state, left-light-on?, and right-light-on?.

# A colored light.
light: (color :Str -> :Arr) {
    [circle: 30 color [pen: "black" 2.0]]
} fun

[rectangle: 300 100 "white"] BACKGROUND!
[rectangle: 50 1 "white"] SPACE!

# Produce an image for the current state.
on-draw: (state :Obj -> :Arr) { 
    state left-light-on? { "yellow"  } { "black" } if left!
    state right-light-on? { "yellow"  } { "black" } if right!
    [overlay: 
        [[beside: [left light SPACE right light]] 
         BACKGROUND]]
} fun

# The animation code.
animate: {
    "Turn Signal" 300 100 initial-state [ # window title, width, and height, initial state
        on-draw: (state) { # called when a redraw is necessary || IF LEFT LIGHT ON, THEN YELLOW, ELSE BLACK; IF RIGHT LIGHT ON, THEN YELLOW, ELSE BLACK
            state on-draw 
        } lam
        on-tick: (state) { # called 60 times per second
            state tick-without-time
        } lam 
        on-key-press: (state key) { # called when a key has been pressed down
            state key key-press-without-time
        } lam 
    ] show
} fun

# Animate only if you are sure that your code works. Graphics output is not
# very robust yet. An error might mean that you have to close the IDE and
# start the IDE again. Always save (Ctrl+S) your work!

# todo: remove comment to animate
animate
